# HTTP
  超文本传输协议
  明文方式发送内容
  无状态协议
  端口 80

  http数据包报文  ->  tcp/ip   ->  服务器
  缺点：
  攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息
  不适合传输 信用卡号、密码等
  不安全

# HTTPS
  超文本传输安全协议
  是以安全为目标的HTTP通道
  简单讲是HTTP的安全版
  即HTTP下加入SSL层
  HTTPS的安全基础是SSL
  因此加密的详细内容就需要SSL
  端口443

  http协议封装好的数据包  + ssl加密   ->  tcp/ip   ->  服务器
  缺点：虽然安全，但是开销变大了，传输速度也变慢了。

  * https又是怎么保证数据的加密传输的呢？
  浏览器如果发现是https传输要进行必要的准备工作才开始发送
  1, 浏览器把协议版本号，支持的加密算法 生成的随机数A发送给服务器。
  2, 服务器接到客户端发送过来的加密算法后，查看自身支持的加密算法，
  确定双方后边使用哪种加密算法，然后把该算法和数字证书以及生成的随机数B发给客户端。
  3, 客户端接到服务器发送过来的证数后，得到证书里的非对称加密的公钥D，
  然后又生成一个随机数C,把C和D加密后得到的一个字符串E发给服务器。

  * 原理
  1. 服务器有一个证书。
  主要目的是保证服务器就是他声称的服务器。//类似该银行ip地址就是他声称的位置
  客户通过信任该证书，从而信任了该主机。
  服务端和客户端之间的所有通讯，都是加密的。
  是客户端产生一个对称的密钥，通过服务器的证书来交换密钥，
  2. 少许会要求客户端也必须有一个证书。个人银行等
  a) 这里客户端证书，其实就屎表示个人信息，这样能够更深的确认客户身份。
  b) 目前大多数个人银行的专业版是这种做法，具体证书可能是拿U盘（即U盾）作为一个证书备份的载体。

# SSL
  加密传输协议
  依靠证书来验证服务器身份
  并为浏览器和服务器之间的通信加密

  加密算法
  认证用户和服务器，确保数据发送到正确的客户机和服务器
  加密数据以防止数据中途被窃取
  维护数据的完整性，确保数据在传输过程中不被改变。

# TLS
  SSL的标准化的产物
  有1.0 1.1 1.2三个版本
  默认使用1.0

# CA
  CA 颁发的证书
  为了解决上面非对称加密被劫持的情况

# 加密

  * 对称加密
  可加密，可解密
  加密解密使用相同的密钥
  
  客户端通过密钥对数据加密
  服务端通过密钥对数据解密

  * 非对称加密

  * 劫持
  窃听者可以伪造服务器的公钥与客户端通讯，客户端以为是跟服务器通讯，其实是与窃听者在通讯。


# 公钥/私钥
  一个公钥对应一个私钥，他们是成对的
  其中一个密钥加密数据，则只有对应的那个密钥才可以解密。

  公钥加密，私钥解密。
  私钥数字签名，公钥验证。（这样就确认了加密人的身份，因为私钥只有创建者知道)

  * 公钥加密例子
  我找了两个数字，一个是1，一个是2。我喜欢2这个数字，就保留起来，不告诉你们(私钥），然后我告诉大家，1是我的公钥。我有一个文件，不能让别人看，我就用1加密了。别人找到了这个文件，但是他不知道2就是解密的私钥啊，所以他解不开，只有我可以用 数字2，就是我的私钥，来解密。这样我就可以保护数据了。

  我的好朋友x用我的公钥1加密了字符a，加密后成了b，放在网上。别人偷到了这个文件，但是别人解不开，因为别人不知道2就是我的私钥， 只有我才能解密，解密后就得到a。这样，我们就可以传送加密的数据了。

  * 私钥签名
  如果我用私钥加密一段数据（当然只有我可以用私钥加密，因为只有我知道2是我的私钥），结果所有的人都看到我的内容了，因为他们都知 道我的公钥是1，那么这种加密有什么用处呢？

  但是我的好朋友x说有人冒充我给他发信。怎么办呢？我把我要发的信，内容是c，用我的私钥2，加密，加密后的内容是d，发给x，再告诉他 解密看是不是c。他用我的公钥1解密，发现果然是c。 这个时候，他会想到，能够用我的公钥解密的数据，必然是用我的私钥加的密。只有我知道我得私钥，因此他就可以确认确实是我发的东西。 这样我们就能确认发送方身份了。这个过程叫做数字签名。

  * https过程
  客户端想要发送重要数据到服务端
  服务端拥有一对公钥和私钥

  1. 打招呼阶段
  客户端请求服务端，告诉服务端我要发送数据了
  2. 首先客户端要确认，它所认为的服务端就是服务端，而不是劫持者
  服务端把一段通过私钥加密的文本（数字签名），和公钥，一起发送给客户端
  客户端如果能通过公钥解密，则确认它就是服务端
  3. 传输数据
  客户端使用公钥把数据加密后，传送给服务端
  服务端用它的私钥解密数据
